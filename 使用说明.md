# 报销信息自动填写系统 - 使用说明

## 项目概述

这是一个基于Python + Playwright的报销信息自动填写系统，可以根据Excel文件中的配置自动填写网页表单。系统支持多种表单元素类型，包括输入框、下拉框、按钮点击等操作。

## 文件结构

```
├── main.py                    # 基础版本主程序
├── reimbursement_automation.py # 增强版主程序（推荐使用）
├── stable_automation.py       # 稳定版本主程序
├── simple_test.py             # 简单测试程序
├── config.py                  # 配置文件
├── requirements.txt           # 项目依赖
├── README.md                  # 项目说明
├── 使用说明.md               # 本文件
├── create_sample_files.py     # 示例文件生成脚本
├── 报销信息.xlsx              # 报销信息Excel文件
├── 标题-ID.xlsx              # 标题-ID映射文件
└── test_page.html             # 测试用HTML页面
```

## 安装和配置

### 1. 安装依赖

```bash
pip install -r requirements.txt
playwright install
```

### 2. 准备数据文件

#### 报销信息.xlsx 文件格式

该文件包含报销信息数据，格式如下：

| 序号 | 姓名 | 金额 | 支付方式 | 报销类型 | 子序列开始 | 子序列结束 |
|------|------|------|----------|----------|------------|------------|
| 1    | 张三 | 100  | 现金     | 差旅费   | 是         |            |
| 1    | 张三 | 200  | 银行卡   | 餐饮费   |            | 是         |
| 2    | 李四 | 150  | 现金     | 办公费   |            |            |

**特殊说明：**
- **序号**：相同序号表示同一条报销记录
- **子序列开始/结束**：用于处理复杂的多行报销记录
- **以`$`开头的内容**：表示按钮点击操作
- **以`@`开头的内容**：表示系统导览框点击操作（如@WF_YB6）
- **下拉框字段**：会自动识别并选择对应选项

#### 标题-ID.xlsx 文件格式

该文件包含表头标题与网页元素ID的映射关系：

| 标题 | 网页元素ID |
|------|------------|
| 姓名 | name_input |
| 金额 | amount_input |
| 支付方式 | payment_method |
| 报销类型 | expense_type |

## 使用方法

### 1. 快速开始

```bash
# 生成示例文件
python create_sample_files.py

# 运行稳定版本（推荐）
python stable_automation.py

# 或运行增强版本
python reimbursement_automation.py
```

### 2. 配置目标网页

修改 `config.py` 中的 `TARGET_URL` 为你的实际网页地址：

```python
TARGET_URL = "http://your-reimbursement-system-url.com"
```

### 3. 自定义配置

在 `config.py` 中可以调整以下参数：

- `HEADLESS`: 是否隐藏浏览器窗口（True/False）
- `BROWSER_TYPE`: 浏览器类型（chromium/firefox/webkit）
- `DROPDOWN_FIELDS`: 下拉框字段列表
- `BUTTON_PREFIX`: 按钮操作前缀（默认"$"）
- `NAVIGATION_PREFIX`: 系统导览框操作前缀（默认"@"）
- 各种等待时间配置

## 程序功能

### 原子操作函数

1. **get_object_id(title)**: 根据标题获取网页元素ID
2. **click_button(element_id)**: 点击按钮
3. **fill_input(element_id, value)**: 填写输入框
4. **select_dropdown(element_id, value)**: 选择下拉框
5. **click_navigation_panel(element_id, value)**: 点击系统导览框

### 核心功能

1. **数据加载**: 读取Excel文件和标题-ID映射
2. **浏览器控制**: 启动指定类型的浏览器
3. **页面导航**: 导航到目标网页
4. **表单填写**: 根据Excel内容填写表单
5. **子序列处理**: 处理复杂的多行记录
6. **系统导览**: 点击系统导览框进行页面跳转
7. **表单提交**: 验证并提交表单
8. **错误处理**: 自动重试和错误日志

### 子序列处理逻辑

系统支持复杂的子序列处理：

1. 当遇到"子序列开始"列时，程序会从当前行开始处理
2. 从左到右处理每一列的数据
3. 当遇到"子序列结束"时，等待后继续处理下一行
4. 直到处理完所有相同序号的记录

### 系统导览框处理逻辑

系统支持多种方式查找和点击系统导览框：

1. **通过ID直接点击**: 如果导览框有明确的ID
2. **通过onclick属性查找**: 查找包含特定onclick属性的div元素
3. **通过title属性查找**: 查找包含特定title属性的div元素
4. **通过class和文本内容查找**: 查找具有特定class的div元素
5. **通过JavaScript执行**: 直接执行onclick函数（如navToPrj）

**使用示例**:
- Excel中填写: `@WF_YB6`
- 对应HTML: `<div onclick="navToPrj('WF_YB6')" title="点击进入">`
- 程序会自动查找并点击该导览框

## 错误处理和调试

### 1. 常见问题

- **文件不存在**: 确保Excel文件路径正确
- **元素找不到**: 检查标题-ID映射是否正确
- **页面加载慢**: 调整等待时间配置
- **浏览器启动失败**: 确保已安装playwright浏览器

### 2. 调试方法

```bash
# 运行简单测试
python simple_test.py

# 查看详细日志
# 日志会输出到控制台和文件中
```

### 3. 日志文件

程序会生成详细的日志文件 `reimbursement_automation.log`，包含：
- 数据加载信息
- 浏览器操作记录
- 表单填写过程
- 错误和警告信息

## 扩展和定制

### 1. 添加新的表单元素类型

在 `process_cell` 方法中添加新的处理逻辑：

```python
# 处理新的元素类型
if title == "新字段":
    await self.handle_new_element(element_id, value_str)
```

### 2. 自定义验证规则

在 `validate_form` 方法中添加验证逻辑：

```python
async def validate_form(self) -> bool:
    # 添加自定义验证规则
    if not await self.check_required_fields():
        return False
    return True
```

### 3. 支持更多Excel格式

修改 `load_data` 方法以支持不同的Excel格式：

```python
# 支持不同的sheet名称
self.reimbursement_data = pd.read_excel(self.excel_file, sheet_name=self.sheet_name)
```

## 最佳实践

### 1. 数据准备

- 确保Excel文件格式正确
- 验证标题-ID映射的准确性
- 测试少量数据后再处理大量数据

### 2. 网页适配

- 根据实际网页调整选择器
- 测试时使用非隐藏模式
- 适当调整等待时间

### 3. 错误处理

- 定期检查日志文件
- 设置合理的重试次数
- 添加数据验证规则

### 4. 性能优化

- 批量处理时适当增加等待时间
- 使用合适的浏览器类型
- 优化Excel文件大小

## 技术支持

如果遇到问题，请检查：

1. 依赖是否正确安装
2. Excel文件格式是否正确
3. 网页元素ID映射是否准确
4. 网络连接是否正常
5. 浏览器是否支持目标网页

## 更新日志

- v1.0: 基础功能实现
- v1.1: 添加子序列处理
- v1.2: 增强错误处理
- v1.3: 优化性能和稳定性 